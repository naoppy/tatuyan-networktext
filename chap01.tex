電気を用いない通信から見てきた通り、通信と記録は密接な関係にある。また、記録の際には記録するべき要素の取捨選択が行われる。人間が直接運ぶにせよ光や音を使うにせよ電気通信にせよ、記録されたものを受け渡しするのが通信であるということに立ち戻れば、記録と通信は表裏一体の関係にあることは明らかであろう。

本章では、離散的な「デジタルデータ」を以下にして表現・記録するかという点について学んでいく。


\section{二元状態とデジタルデータの特徴}

伝言ゲームでは、なかなか情報が正確に伝わらない。この例を見てもわかる通り、通信は記録と伝達手段(伝送路)の双方において正確・確実であり、途中で内容が変化しないことが求められる。

\subsection{記録の条件と二元状態}
記録、すなわち表現において正確性や確実性を担保するためには、次のような条件が必要となろう。
\begin{itemize}
\item いくつかの状態に明確に分かれることあるいは定量的であること。
\item 内容によらず表現方法が統一されていること。
\item 伝送や処理に適した、単純な形態であること。
\end{itemize}

この条件を満たす最も端的な表現として、\textbf{二元状態}\index{にげんじょうたい@二元状態}：明確な二つの状態でそれ以外の状態のないもの があり、実際のデータ伝送において広く用いられている。通信において使われる二元状態は、2進数(0/1)のほか、論理(T/F)、極性(+-)、電流の有無、スイッチのon/offなどが代表的だが、センサの通信などにも目を向ければ動静(動きの有無)、音声(声の有無)なども通信に使われている二元状態といえよう。この二元状態が通信に使われる理由としては、以下のようなものが挙げられる。
\begin{itembox}[l]{二元状態の通信における利点}
\begin{itemize}
\item はっきりと状態の区別がつき、検出も容易で、誤りも生じにくい
\item 多くの電気的状態に一致し、情報の伝送や記憶に有効である
\item 数字の0/1に対応させて2進数表現することで四則・ビット演算を適用できる
\end{itemize}
\end{itembox}

\subsection{デジタルデータの特徴}
デジタルとはよく聞く言葉であるが、この訳語「離散量」あるいは「計数」はそれほど馴染みがない言葉かもしれない。デジタルというのは幾つかの、飛び飛びの状態を取る量という意味であり、対してアナログは連続的に値が定まる。例えば電車の線路が始点からどれだけの距離にあるかはアナログであるが、現在居る駅という情報はデジタルと言える。針が連続に動くアナログ時計は（現実に読み取れるか、その精度はどうかというのは別にして）10.232秒など小数点以下の秒数も表しているが、デジタル時計では数字として表示される桁数以上の情報は捨てられている。

このように、デジタルデータは離散的な有限個の状態に最初からデータが分かれているため、各々に2進数値を対応させることで二元状態の羅列によりデータを表現できる。また、状態が有限個であり、2進数値に対応付けるときに誤差が生じることがない。この例としては、ある文字を音声と書き文字の双方で伝える場合を考えてみよう。文字を音声で伝える際、例えば"し"と"ひ"がごく近い発音だとどちらの文字かひどく伝わりづらいことがある（実際に、江戸言葉や上方言葉ではこれらが混同した発音あるいは入れ替わることがある）。このため、「執事」と「羊」や「しなびた」と「ひなびた」など、"し"と"ひ"しか違いのない2つの言葉は時として文脈などから推定せざるを得ないこととなる。だが、書いている文字であればどちらを指しているのかは一目瞭然であり誤解の恐れはない。ここで挙げたのは極端な例であるが、デジタルデータは最初から状態が明確に分かれていることがアドバンテージとなっているということである。

\subsection{【補足】2進数・記数法について}
\begin{center}
\begin{minipage}[]{0.75\linewidth}
\begin{screen}
\begin{center}
本節は前提知識の補足である。\\
既知の読者におかれては飛ばして次節を読まれたい。
\end{center}
\end{screen}
\end{minipage}
\end{center}

先の解説で2進数を用いたが、記数法について慣れない読者に向け、補足解説を記す。

我々が物を数える際には手の10本の指を用いる。ここから物を数える位取りとして、指がいっぱいになったら位を1増やすということで\textbf{10進法}\index{じっしんほう@10進法}が生まれた。10進法とは、10(十、ten)毎に位がひとつ上がるような数え方であり、我々が普段使っている数の表記法である。10進法により表された数のことを\textbf{10進数}\index{じっしんすう@10進数}と呼ぶ。

一方、先の二元状態は2つの指を持つといえる。そこで、2毎に位がひとつ上がり、0,1,10,11,...と数える\textbf{2進法}\index{にしんほう@2進法}を使う。

これらのような、数の表記にあたりどのようにして位をとるかの方法を\textbf{位取り記数法}\index{くらいどりきすうほう@位取り記数法}(positional notation)あるいは単に\textbf{記数法}\index{きすうほう@記数法}と呼ぶ。また、その位取りの基準となる数(10進法なら10、2進法なら2)を\textbf{基数}\index{きすう@基数}と呼ぶ。

\subsubsection{記数法の一般論}
先までの例と同様に、指の本数から考えよう。指が$n(\ge2)$本しかないと仮定する。このときは、$n$本がいっぱいになったら次の位に移る。たとえば、指が3本しかなければ、3になったら次の位に移るようにして数えることができる。

一般の自然数$n$に対して、$n$進法とは、$n$を基数にする方法である。つまり、数えていって、$n$に達する毎に上の位に移るという事である。

例えば、123という数字を考えよう。これは、123個の1であるが、同時に12個の10と3個の1である。更に分ければ、1個の100と2個の10と3個の1と分かれる。つまり、$10^k$の束がいくつあるかを数え、それが10個に達したら$10^{k+1}$を1増やす。これによって、各位は$10^{k+1}$の束にならない余りとなる。

上記に従って位取りをしてみよう。10進法では、小数点の直上を$10^0$とし、その上の桁を$10^1,10^2,\cdots$、小数点以下を$10^{-1},10^{-2},\cdots$としている。この10を$n$に変えたのが$n$進法である。たとえば、2進法における11111は$2^4\times1+\cdots+2^0\times1=31$である。

$n$進法で使われる数字は、$n$種類ある。2進法なら0と1だし、10進法なら0, 1, 2, 3, 4, 5, 6, 7, 8, 9であり、16進法の場合は0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, fである\footnote{アルファベットは大文字を用いることもある。C言語ではどちらを用いても構わない。}。数字だけでは何進法であるかわからない場合もあるため、これを明確にするときには、数字の右下に$33_{(n)}$のように記す。たとえば、$101.1_{(2)}=5.5_{(10)}$である。

\subsubsection{記数法の変換}
$n$進法から10進法への変換はどのように行うだろうか。これは$n$進法の仕組みを考えてみればわかる。

$n^k$の位が$a_k$であるような数字$A$の10進法での値は定義から次のように求められる。
\begin{itembox}[l]{$n$進法から10進法への変換}
$n^k$の位が$a_k$であるような数字$A_{(n)}$は、10進法において
\begin{equation*}
A_{(10)}=\sum_{k}a_k\times n^k
\end{equation*}
と計算できる。
\end{itembox}
逆に、10進法から$n$進法に変える場合は、どうすればよいだろうか。

1つには、単に「取り尽くす」方法がある。つまり、$n^k$のうち、元の数を超えない最大のものを見つけ、その数で元の数を割った商を$n^k$の位にし、余りについて$n^{k-1}$で割り…と繰り返すのである。特に、小数点がある場合はこの方法を利用すると楽である。

だが、この計算はやや面倒に感じることもあろう。そこで、主に整数向けであるが、先に書いた位取りの考えを用いる方法がある。

$n^k$の位が$a_k$であるという事は、$n^k$で割った後に、小数点以下を切り捨て、$n$に対する剰余を取ると$a_k$になる、という事である。例えば、10進法で100の位の数字を出したいとすれば、100で割って10による余りを取れば良い。これと同じ性質が一般の$n$進法にも成立する。この性質を利用し、次のような手順を踏んで記数法を変換できる。
\begin{itembox}[l]{10進法から$n$進法への変換}
\begin{enumerate}
\item 変換したい10進数を$n$で割り、その余りを別におく。
\item これを、商が0になるまで繰り返す。
\item 別においた余りを逆順に並べると$n$進数での表記になる。
\end{enumerate}
\end{itembox}

いくつかの数を変換してみればわかるが、10進整数は他の記数法でも整数である。一方、ある記数法で有限小数であるからと言って他の記数法で有限小数であるとは限らない。例えば、1/3は、10進法では無限小数だが、3進法であれば0.1$_{(3)}$とシンプルに表せる。

\section{情報の符号化}
先にデジタルデータを2進数化して表現することを論じた。情報内容を変えることなく、0/1などの組み合わせで表現することを\textbf{符号化}\index{ふごうか@符号化}という。ここでは整数や文字と言った典型的なデジタルデータの表現方法(=符号化)を説明する。また、やや歴史的な符号化の例としてモールス符号を、デジタルでアナログを近似している例として小数の表現方法を紹介する。

なお、これ以降の議論については、二元状態として\textbf{bit}\index{bit}(binary digitの略で二進数の意)を用いるものとし、8bitである場合の表現として1\textbf{byte(バイト)}\index{byte}あるいは（歴史的経緯により）特に8bitであることを強調したい際には1\textbf{octet(オクテット)}\index{octet}を用いる\footnote{2008年まで、1byte=8bitであることは主流でこそあったものの明確な定義として定まっておらず、1byteが8bitでない環境も存在していた。2008年にISO（国際標準化機構）やIEC（国際電気標準会議）において1byte=1octetが正式に定まったため、現在では1byte=8bitとして考えて問題はないが、追随できていない環境などでは1byteが8bitでない可能性もありうる。このことから、本書においては8bitであることが特に重要な場合には旧来の1octetという表記を用いることとした。}。

\subsection{整数の表現}
2進数での表現として最も単純なのは符号なし整数であろう。符号なしの整数をそのまま2進数に変換し、これをビットパターンとする方法である。$N$bitにより、0以上$2^{N}$未満の整数が表現される。

一方、符号付き整数を扱う場合にはどうだろうか。例えば、先頭の1ビットを符号に割り当てるなどの方法が考えられる。だが、この方法では+0と-0が出る、符号の扱いの都合でCPUの実装等が複雑になるなどの難点がある。これらの理由の回避のため、近年の電子計算機では\textbf{2の補数}\index{2のほすう@2の補数}表現が用いられることが多い。

この表現は、次のようなものである。

まず、0を基準とする。10進法における0を、2進法における0と対応させるのは自然な考えであろう。さて、これから1を引いた数、すなわち-1をどう表すべきであろうか？？

4ビットで考えることとしよう。1=0001から1を引くと0=0000になる。では、それより1小さいものはどうすればいいか。これは、1111とすれば良いのである。ビットがあふれる部分への繰り上がりあるいはその部分からの繰り下がりを無視して考えれば、0000-1=1111であるし、足し算で考えても1111+0001=0000, 0000+0001=0001となる。また、嬉しいことに、この方法を用いた場合でも、先頭ビット0は+または符号なしを、1は-を示す。このように、-aのビット表現を、0からaを引いたものとして表現するのが2の補数表現である。

参考として、表\ref{table_sec2}に、2の補数表現を用いた4ビットの場合の符号なし整数・符号あり整数一覧を示す。
\begin{table}[htb]
\centering
\caption{4bit符号なし整数・符号あり整数の一覧}\label{table_sec2}
\begin{tabular}{|c|c|c||c|c|c|}\hline
ビット列&符号なし整数&符号あり整数&ビット列&符号なし整数&符号あり整数\\ \hline
&&&&&\\[-16pt]\hline
0000&0&0&1000&8&-8\\ \hline
0001&1&1&1001&9&-7\\ \hline
0010&2&2&1010&10&-6\\ \hline
0011&3&3&1011&11&-5\\ \hline
0100&4&4&1100&12&-4\\ \hline
0101&5&5&1101&13&-3\\ \hline
0110&6&6&1110&14&-2\\ \hline
0111&7&7&1111&15&-1\\ \hline
\end{tabular}
\end{table}

この例を見てもわかるように、(桁溢れの繰り上がりを無視すれば)2進数・10進数とも順に並んでいるのが2の補数表現の特徴である。また、符号を用いた表現と違い0が1つになっており、-8から7までと、負の側は絶対値が1大きい値まで収まる。

\subsubsection{【補遺】補数の意味}
\begin{center}
\begin{minipage}[]{0.75\linewidth}
\begin{screen}
\begin{center}
本節は大筋に影響しない。\\
難解あるいは興味索然たるものと感じる折には\\
飛ばして次節を読まれたい。
\end{center}
\end{screen}
\end{minipage}
\end{center}

先の解説では2の補数表現について補数とは何か説明せずに仕組みのみを述べた。本節では、関心ある読者諸賢に向け、\textbf{補数}\index{ほすう@補数}の意味について解説する。

ある基数$b$における自然数$a$の補数とは、$a$に足した時に桁が1増えるような最小の自然数$c$のことをいう\footnote{厳密にはこの$c$を($b$進法における)基数の補数($b$の補数)と、$c$を1小さくしたものを($b$進法における)減基数の補数($b-1$の補数)と呼ぶ。本書で出てくるのは全て前者である}。10進法における74に対する補数は26である。2進数において$1100_{(2)}=12_{(10)}$の補数は$100_{(2)}=4_{(10)}$である。

先に出てきた2の補数表現とは、2進数における$a$の補数を$-a$として使う($a>0$)という考えである。但し、一般の補数では直上の1桁が増えるかどうか見るところ、この表現においては扱うサイズで桁溢れが起きるかどうかにより判断をする。換言すれば、「符号なし整数の最大値+1から$a$を引いた値」といえる。先に挙げた4bitにおける5(0101)の補数は、4bitが桁溢れを起こすような最小の自然数、つまり16(10000)-5(0101)=11(1011)である。そこで、1011という表現を-5の表現とする。同じように、$a$の補数の符号なし整数表現(2進数表現)を$-a$として使う($a>0$)というのが、2の補数表現である。


\subsection{文字の表現}
デジタルデータとして文字を表現する場合には、それぞれの2進数値に対応した文字を定める。これを\textbf{文字コード}\index{もじこーど@文字コード}と呼ぶ。例えば、最も一般的な文字コードと言えるASCII(American Standard Code for Information Interchange)の場合、数字の9は57となり、文字Aは65に割り当てられている。ここではASCIIの例を出したが、文字コードには様々な種類があり、それによって同じ数字でも違う文字に割り当てられることがある。
% ASCIIコードを載せておくか？

1オクテットでは256通りの文字しか表わせないため、日本ではひらがな・カタカナ・漢字を表すのに不十分である。そのため、日本語を扱う際などには、それらにも対応したShift\_JISやEUC-JP(Extended UNIX Code Packed Format for Japanese)、UTF-8などの日本語の文字コードを使うことになる。Webページなどを閲覧している時に文字化けして見えることがあるが、この多くは異なる文字コードを使っていることによるものである。異なる文字コードであれば当然違う文字が割り当てられているため、本来と違うコードによって解釈されてしまうと意図した文字と異なる文字として扱われるということである。

\subsection{モールス符号}
% 未記述

\subsection{小数の表現}
小数は(無限小数なども含めれば)文字や整数と違い、連続的な(アナログな)データである。このため、先に挙げたデジタルデータの利点である「元から離散的で有限個」という性質がなく、デジタル表現のために「最も近い表現可能な値」に丸める必要がある。これは次章のアナログデータの表現で出てくる量子化というステップであり、これによる誤差(プログラミングの世界では一般に丸め誤差という)は量子化雑音に相当する。

コンピュータ等で扱う小数は、数学等の小数と違い、表せる個数が限られたデジタルデータである。本来はアナログデータである小数を出来る限り近い値で表せるように考えられたデジタル表現とも言える。その表現方法には\textbf{固定小数点数表現}\index{こていしょうすうてんすうひょうげん@固定小数点数表現}と\textbf{浮動小数点数表現}\index{ふどうしょうすうてんすうひょうげん@浮動小数点数表現}がある\footnote{それぞれ、固定-小数点-数、浮動-小数点-数と区切る。対応する英語も、fixed point number,floating point numberである。}。

\subsubsection{固定小数点数}
ある定まったビットまでを整数部として、そこから下の部を小数部としてみなすことでしょうすうを表現する方法を、固定小数点数表現\index{こていしょうすうてんすうひょうげん@固定小数点数表現}という。例えば、16ビットある時に、上位8ビットがその数の整数部を示し、下位8ビットが小数部を示すようにすれば良い。この時、$2^0=1$を示すビットのすぐ下のビットは$2^{-1}$を、その下は$2^{-2}$を$\cdots$というように、桁が連続的に定まっていくのが普通である。

この方式は表現できる数の範囲はごく限られるものの(例えば先の16bitの例ならば、10進数で1/256刻みの値しか扱えない)、定められた範囲においては、誤差を出すことなく高速に計算できる。10の累乗で表現するような値が頻出する科学計算では利用しづらいが、桁数がある程度定まっている上に誤差が大きな問題となる経済計算などで用いられる。

\subsubsection{浮動小数点数}
浮動小数点数表現\index{ふどうしょうすうてんすうひょうげん@浮動小数点数表現}は、小数点の場所を上手く変えながら(浮動)表す方法である。浮動小数点数では、表したい数をまず以下の形式で表現する。
\[\text{(符号)}\text{(仮数)}\times\text{(基数)}^\text{(指数)}\]
この内、基数は通常2が用いられる。また、仮数は1以上2未満の数である(これにより、上記の形式での表現が一意に定まる)。そして、符号(1bit)、指数(符号付き整数)、仮数の小数部(固定小数点数)を各々保存する。例えば、-4.8という数字を浮動小数点数で表現することを考えよう。$-4.8=-1.2\times 2^2$である。したがって、符号部には-が、仮数部には0.2が、指数部には2が格納されることになる。なお、指数・仮数を何bitとするかは規格によって異なるが、近年のコンピュータではIEEE754という規格に従っていることが多い。

固定小数点数型に比べ、指数部の表現によって科学計算などで用いるような大小様々な値に比較的近い値を表現できるが、誤差が出たり、計算の時間がかかったりといった問題点もある。固定小数点数型は狭い範囲を等間隔に区切っている表現であるが、浮動小数点数は広い範囲をその絶対値に応じてスケーリングして区切っているという見方もできる。


\section{符号化効率の改善と圧縮}
データの記録や通信の資源は限られているため、少しでも効率よく記録・通信したい。先に挙げたモールス信号は光あるいは音を人間が認識して行うことから伝達に時間がかかる。そのため、少しでも短縮するために文字の出現頻度を考慮して符号の長さが決まっていた。同様に、何らかの手法を用いてデータを\textbf{圧縮}\index{あっしゅく@圧縮}して符号化する、あるいは符号化したものを圧縮する方法が考えられた。

\subsection{符号化効率の改善}
% 未記述

\subsection{エントロピー符号}
先のモールス符号である程度考慮されていたように、元の情報の頻度に偏りがある場合、高頻度のものを短い符号に割り当てることで平均的な符号を短くすることができる。このように、出現頻度によって長さを変えて割り当てる符号を\textbf{エントロピー符号}\index{えんとろぴーふごう@エントロピー符号}と呼ぶ。
% 未記述

エントロピー符号の最も基本的なものとして、\textbf{ハフマン符号}\index{はふまんふごう@ハフマン符号}を紹介する。
% 未記述

\subsection{その他の圧縮法}
% 未記述


\section*{演習問題}
\begin{problems}
\item 古いゲームにおいては、容量の制約から16bitの整数型などを採用せざるを得なかった。そのため、例えば(0以下の場合は0以下になった時の処理が必要となる)体力などの数値は32768が最大となっていた(現実には、これを3〜4データ用意するなどして増強を図っていた)。ところが、この最大値は2の補数表現を採用した16bit符号付き整数型の最大値と1異なる。内部上の表現は確かに2の補数表現で間違いなく、処理によってこの違いが生じているのだが、どのような処理をしていると考えられるか説明せよ。 

\item データの種類数と、各データの出現比率が与えられるとき、そのハフマン符号化の例と、その際の平均符号長を出力するプログラムを作成せよ。例えば、4種のデータが以下のような比率で入力される場合、平均符号長は1.75となる。
\begin{table}
\centering
\caption{ハフマン符号化を考えるデータ例}
\begin{tabular}{|c||c|c|c|c|}\hline
データ種別 & A & B & C & D \\ \hline
出現頻度 & 4 & 2 & 1 & 1 \\ \hline
符号例 & 0 & 10 & 110 & 111 \\ \hline
\end{tabular}
\end{table}
なお、簡単のために出現頻度は正整数値で、その合計は50000を超えないものとして良い。

\item 浮動小数点数の配列を圧縮して送りたい場合、単純なランレングスでは効果が出づらい。そこで、各値の同一ビットのみを集めてランレングスをかけ、これを順に記すことで圧縮することを考える。すなわち、1ビット目のランレングス情報、2ビット目のランレングス情報…と書かれたデータを作成して圧縮するのである。この手法について以下の問いに答えよ。
\begin{enumerate}
\item 浮動小数点数の配列にどのような傾向があるときにこの圧縮は効果的か。
\item 整数や文字の配列の場合、この圧縮は効果的と言えるか。
\end{enumerate}

\end{problems}
